#include "hedgelib/materials/hl_material.h"
#include "hedgelib/io/hl_file.h"
#include "hedgelib/hl_math.h"
#include <stdio.h>
#include <string.h>

static HlResult hlINMaterialWriteMTL(const HlMaterial* HL_RESTRICT material,
    size_t materialIndex, HlStream* HL_RESTRICT stream)
{
    size_t i;
    char buf[255];
    int len;
    HlResult result;
    
    /* Write newmtl data to stream. */
    if (material->name)
    {
        /* Write "newmtl " to stream. */
        result = HL_STREAM_WRITE_TEXT_UTF8(stream, "newmtl ", NULL);
        if (HL_FAILED(result)) return result;

        /* Write material name to stream. */
        result = hlStreamWrite(stream, strlen(material->name),
            material->name, NULL);

        if (HL_FAILED(result)) return result;

        /* Write newline character to stream. */
        result = HL_STREAM_WRITE_TEXT_UTF8(stream, "\n", NULL);
        if (HL_FAILED(result)) return result;
    }
    else
    {
        /* Store material name data in buffer. */
        len = sprintf(buf, "newmtl default_%lu\n",
            (unsigned long)(materialIndex + 1));

        if (len < 0) return HL_ERROR_UNKNOWN;

        /* Write material name data to stream. */
        result = hlStreamWrite(stream, len, buf, NULL);
        if (HL_FAILED(result)) return result;
    }

    /* Write parameters. */
    for (i = 0; i < material->paramCount; ++i)
    {
        const HlVector4* values;

        /* Skip this parameter if it's not a float4. */
        if (material->params[i].format != HL_MATERIAL_PARAM_FORMAT_FLOAT4)
            continue;

        /* Get values pointer. */
        values = (const HlVector4*)material->params[i].values;

        if (!strcmp(material->params[i].name, "diffuse"))
        {
            /* Store data in buffer. */
            len = sprintf(buf, "Kd %f %f %f\n",
                values->x, values->y, values->z);

            if (len < 0) return HL_ERROR_UNKNOWN;
        }
        else if (!strcmp(material->params[i].name, "ambient"))
        {
            /* Store data in buffer. */
            len = sprintf(buf, "Ka %f %f %f\n",
                values->x, values->y, values->z);

            if (len < 0) return HL_ERROR_UNKNOWN;
        }
        else if (!strcmp(material->params[i].name, "specular"))
        {
            /* Store data in buffer. */
            len = sprintf(buf, "Ks %f %f %f\n",
                values->x, values->y, values->z);

            if (len < 0) return HL_ERROR_UNKNOWN;
        }
        
        /* TODO: Anything else common that we might want to export to the mtl? */

        /* Otherwise, skip this parameter; mtl doesn't support this. */
        else continue;

        /* Write data to stream. */
        result = hlStreamWrite(stream, len, buf, NULL);
        if (HL_FAILED(result)) return result;
    }

    /* Return early if there is no texset loaded. */
    if (material->texset.refType != HL_REF_TYPE_PTR)
        return HL_RESULT_SUCCESS;

    /* Write textures. */
    for (i = 0; i < material->texset.data.ptr->textureCount; ++i)
    {
        const HlTextureEntry* texEntry = &material->texset.data.ptr->textures[i];

        if (!strcmp(texEntry->type, "diffuse"))
        {
            /* Store data in buffer. */
            len = sprintf(buf, "map_Kd %s.dds\n",
                texEntry->texFileName);

            if (len < 0) return HL_ERROR_UNKNOWN;
        }
        else if (!strcmp(texEntry->type, "ambient"))
        {
            /* Store data in buffer. */
            len = sprintf(buf, "map_Ka %s.dds\n",
                texEntry->texFileName);

            if (len < 0) return HL_ERROR_UNKNOWN;
        }
        else if (!strcmp(texEntry->type, "specular"))
        {
            /* Store data in buffer. */
            len = sprintf(buf, "map_Ks %s.dds\n",
                texEntry->texFileName);

            if (len < 0) return HL_ERROR_UNKNOWN;
        }

        /* TODO: Anything else common that we might want to export to the mtl? */

        /* Otherwise, skip this parameter; mtl doesn't support this. */
        else continue;

        /* Write data to stream. */
        result = hlStreamWrite(stream, len, buf, NULL);
        if (HL_FAILED(result)) return result;
    }

    /* Return success. */
    return HL_RESULT_SUCCESS;
}

HlResult hlMaterialWriteMTL(
    const HlMaterial* const HL_RESTRICT * HL_RESTRICT materials,
    size_t materialCount, HlStream* HL_RESTRICT stream)
{
    size_t i;
    HlResult result;

    /* Write "Generated by HedgeLib" comment. */
    result = HL_STREAM_WRITE_TEXT_UTF8(stream, "# Generated by HedgeLib\n", NULL);
    if (HL_FAILED(result)) return result;

    /* Write objects. */
    for (i = 0; i < materialCount; ++i)
    {
        result = hlINMaterialWriteMTL(materials[i], i, stream);
        if (HL_FAILED(result)) return result;
    }

    return HL_RESULT_SUCCESS;
}

HlResult hlMaterialExportMTL(
    const HlMaterial* const HL_RESTRICT * HL_RESTRICT materials,
    size_t materialCount, const HlNChar* HL_RESTRICT filePath)
{
    HlFileStream* file;
    HlResult result;

    /* Open file. */
    result = hlFileStreamOpen(filePath, HL_FILE_MODE_WRITE, &file);
    if (HL_FAILED(result)) return result;

    /* Write MTL to file, close it, and return. */
    result = hlMaterialWriteMTL(materials, materialCount, file);
    if (HL_FAILED(result))
    {
        hlFileStreamClose(file);
        return result;
    }

    return hlFileStreamClose(file);
}
